<h2>負数を表現する2の補数表現</h2>

負数を表現するための2の補数表現について解説します。

8bit符号あり整数型の<a href="/blog/20201117090747.html">int8_t</a>の例で解説します。

コンピューターアーキテクチャでは、負の数を表現する方法が、いくつかあります。2の補数表現は、その一つです。

2の補数表現を具体的に書き出してみます。

<table>
  <tr><td>負の数</td><td>負の数のビット表現</td><td>正の数(0含む)</td><td>正の数のビット表現</td></tr>
  <tr><td>-1</td><td>11111111</td><td>0</td><td>00000000</td></tr>
  <tr><td>-2</td><td>11111110</td><td>1</td><td>00000001</td></tr>
  <tr><td>-3</td><td>11111101</td><td>2</td><td>00000010</td></tr>
  <tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
  <tr><td>-126</td><td>10000010</td><td>125</td><td>01111101</td></tr>
  <tr><td>-127</td><td>10000001</td><td>126</td><td>01111110</td></tr>
  <tr><td>-128</td><td>10000000</td><td>127</td><td>01111111</td></tr>
</table>

2の補数表現の特徴を見てみましょう。

<ul>
  <li>最上位ビットが0の場合は正数。最上位ビットが1の場合は負数</li>
  <li>127(正の最大値)は01111111</li>
  <li>-1は、11111111</li>
  <li>-128は、10000000</li>
  <li>ビットを反転させて和をとると-1(11111111)になる</li>
</ul>

2の補数の定義は、どこにでも解説があるので、調べてみてくださいね(笑)。

<h3>負数は2の補数表現であると想定してもかまいませんか?</h3>

C言語仕様では、負数は2の補数であるとは、定義されていませんが、実際の多くの処理系では、負数の表現は、他の表現よりも、2の補数であるほうがずっと多いと考えます。

正の最大値に1を加えたときに、負の最小値になるのであれば、処理系が負数に2の補数表現を使っていると確信できます。

数値計算ライブラリが、処理系に負数の表現が2の補数であることを求めるのであれば、簡単な計算でチェックできます。

<h3>2の補数の特徴は何ですか?</h3>

2の補数の特徴は、引き算を足し算で表現できることです。

<pre>
2 - 3 = -1
</pre>

これは以下と同じ。

<pre>
# 00000010 + 11111101 = 11111111
2 + (-3) = -1
</pre>

<h3>どこらへんに2の補数の2というニュアンスがあるのですか?</h3>

名前の付け方が、まずかったのかもしれません...。

無理やりこう考えます。

第一番目に発見された補数を、1の補数と呼びましょう。単なるビット反転で、符号が変わります。

第二番目に発見された補数を、2の補数と呼びましょう。単なるビット反転に、1を足す操作を加えると、符号が変わります。
