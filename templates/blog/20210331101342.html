<h2>C言語の文字列 書き始め</h2>

C言語の文字列について解説します。C言語には、文字列という型はなく、文字の<a href="/blog/20210129143859.html">配列</a>を使って文字列を表現します。C言語の文字列は「\0」で終わります。printf関数の「%s」というフォーマットで文字列を出力できます。

<pre>
#include <stdio.h>

int main(void) {
  // 文字列は、文字の配列で表現し、「\0」で終わる。
  char string[4];
  string[0] = 'a';
  string[1] = 'b';
  string[2] = 'c';
  string[3] = '\0';
  
  // 文字列を出力
  printf("%s\n", string);
}
</pre>

出力結果です。

<pre>
abc
</pre>

<h4>char型は文字を表現する型</h4>

<a href="/blog/20201204103322.html">char型</a>はC言語で文字を表現する型で「符号あり、または符号なしの8bit整数」として定義されています。ASCII文字コードを代入することを想定していると考えられます。

<h4>文字リテラル</h4>

「'a'」は文字リテラルです。対応するASCIIコードに変換されます。「'a'」の場合は、97に変換されます。

<h4>文字列リテラル</h4>

文字列リテラルを使って、文字列を簡単に表現することができます。文字列リテラルは、文字配列の先頭の<a href="/blog/20210211090234.html">アドレス</a>を返すので<a href="/blog/20201208125815.html">char*型</a>で受け取ります。文字列が変更されないようにconst修飾子をつけておくのがよいでしょう。以下が、文字列を表現するC言語のお勧めの表現です。

<pre>
#include <stdio.h>

int main(void) {
  // 文字列リテラル
  const char* string = "abc";
  
  // 文字列を出力
  printf("%s\n", string);
}
</pre>

<h3>動的に文字列を作成</h3>

動的に文字列を作成するには、<a href="/blog/20210209082644.html">calloc関数</a>を使って、メモリを確保します。使い終わったら、<a href="/blog/20210329101342.html">free関数</a>で解放します。

<pre>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 長さが3の文字列のためにメモリを確保。
  // C言語の文字列の末尾は「\0」である必要があるため、1バイト多く確保する
  char* string = calloc(4, sizeof(char));
  
  string[0] = 'a';
  string[1] = 'b';
  string[2] = 'c';
  string[3] = '\0';
  
  printf("%s\n", string);

  // 使い終わったら解放
  free(string);
}
</pre>

出力結果です。

<pre>
abc
</pre>

C言語の文字列は「\0」で終わるので、余分にメモリを確保しておいても特に問題はありません。定数文字列ではなく、追加する必要があるのであれば、多くメモリ領域をとることもできます。100バイトのメモリ領域を確保する例です。

<pre>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  // 長さが3の文字列のためにメモリを確保。
  // C言語の文字列の末尾は「\0」である必要があるため、1バイト多く確保する
  char* string = calloc(100, sizeof(char));
  
  string[0] = 'a';
  string[1] = 'b';
  string[2] = 'c';
  string[3] = '\0';
  
  printf("%s\n", string);
  
  // 使い終わったら解放
  free(string);
}
</pre>

出力結果です。

<pre>
abc
</pre>

<h3>文字列のメモリ領域の再割り当て</h3>

文字列のメモリ領域の再割り当てをするには、新しくメモリを確保し、<a href="/blog/20210221132505.html">memcpy関数</a>で、前の文字列をコピーします。以前のメモリ領域を解放し、新しい文字列を再代入します。

<pre>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

int main(void) {
  // 長さが3の文字列のためにメモリを確保。
  // C言語の文字列の末尾は「\0」である必要があるため、1バイト多く確保する
  int32_t capacity = 4;
  char* string = calloc(capacity, sizeof(char));
  
  string[0] = 'a';
  string[1] = 'b';
  string[2] = 'c';
  string[3] = '\0';
  
  printf("Before %s\n", string);

  // 長さを5にしたい
  int32_t new_capacity = 6;
  char* new_string = calloc(new_capacity, sizeof(char));
  
  // 前の文字列をコピー
  memcpy(new_string, string, capacity - 1);
  
  // 新しい文字を追加
  new_string[3] = 'd';
  new_string[4] = 'e';
  new_string[5] = '\0';
  
  // 古い文字列を解放
  free(string);
  
  // 新しい文字列と入れ替え
  string = new_string;
  new_string = NULL;
  
  printf("After  %s\n", string);
}
</pre>

出力結果です。

<pre>

</pre>

メモリ領域の再割り当ては<a href="http://www.c-tipsref.com/reference/stdlib/realloc.html">realloc関数</a>を使ってもでき、高速ですが、reallocは、処理系によって実装が異なり、バグが再現しにくいという経験があるので、パフォーマンスに問題がなければ、callocを使ってメモリの再割り当てを行う方が安心と感じます。
