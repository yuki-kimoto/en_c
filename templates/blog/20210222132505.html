<h2>C言語の型変換規則</h2>

C言語の型変換規則について解説します。この解説では、よく使う型変換規則を中心にして、実用の観点から解説します。

<h3>ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換(情報喪失なし)</h3>

ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換について解説します。

符号あり整数型として、<a href="/blog/20201117090747.html">int8_t</a>, <a href="/blog/20201126090559.html">int16_t</a>, <a href="/blog/20201130082751.html">int32_t</a>, <a href="/blog/20201127082751.html">int64_t</a>の場合を想定して解説します。

ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換は数値の絶対値と符号の情報は失われずに保持されます。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int8_tからint32_tへ変換
  int8_t num_i8 = -15;
  int32_t num_i32 = num_i8;
  
  printf("%d\n", num_i32);
}
</pre>

出力結果です。

<pre>
-15
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -15 8bit符号あり整数
1001111

// -15 32bit符号あり整数
10000000 00000000 00000000 00001111
</pre>

<h3>ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換(情報喪失なし)</h3>

ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換について解説します。

符号なし整数型として、<a href="/blog/20201122084622.html">uint8_t</a>, <a href="/blog/20201120084622.html">uint16_t</a>, <a href="/blog/20201111150850.html">uint32_t</a>, <a href="/blog/20201109150850.html">uint64_t</a>の場合を想定して解説します。

ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換は数値の情報は失われずに保持されます。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int8_tからint32_tへ変換
  uint8_t num_ui8 = 15;
  uint32_t num_ui32 = num_ui8;
  
  printf("%d\n", num_ui32);
}
</pre>

出力結果です。

<pre>
15
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 15 8bit符号なし整数
0001111

// 15 32bit符号なし整数
00000000 00000000 00000000 00001111
</pre>

<h3>ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換(情報喪失あり)</h3>

ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換について解説します。

符号あり整数型として、<a href="/blog/20201117090747.html">int8_t</a>, <a href="/blog/20201126090559.html">int16_t</a>, <a href="/blog/20201130082751.html">int32_t</a>, <a href="/blog/20201127082751.html">int64_t</a>の場合を想定して解説します。

ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換は、上位ビットが切り捨てられて解釈された値になります。

正しく変換できるのは、変換前の値が、変換後の型で表現できる数値の範囲に収まっていた場合です。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  int16_t num_i16 = -128;
  int8_t num_i8 = num_i16;
  
  printf("%d\n", num_i8);
}
</pre>

出力結果です。

<pre>
-128
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -128 16bit符号あり整数
11111111 10000000

// -128 8bit符号あり整数
10000000
</pre>

情報喪失ありのサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  int16_t num_i16 = -257;
  int8_t num_i8 = num_i16;
  
  printf("%d\n", num_i8);
}
</pre>

出力結果です。

<pre>
-1
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -257 16bit符号あり整数
11111110 11111111

// -1 8bit符号あり整数
11111111
</pre>

<h3>ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換(情報喪失あり)</h3>

ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換について解説します。

符号なし整数型として、<a href="/blog/20201122084622.html">uint8_t</a>, <a href="/blog/20201120084622.html">uint16_t</a>, <a href="/blog/20201111150850.html">uint32_t</a>, <a href="/blog/20201109150850.html">uint64_t</a>の場合を想定して解説します。

ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換は、上位ビットが切り捨てられて解釈された値になります。

正しく変換できるのは、変換前の値が、変換後の型で表現できる数値の範囲に収まっていた場合です。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  uint16_t num_ui16 = 255;
  uint8_t num_ui8 = num_ui16;
  
  printf("%d\n", num_ui8);
}
</pre>

出力結果です。

<pre>
255
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 255 16bit符号なし整数
00000000 10000000

// -128 8bit符号なし整数
10000000
</pre>

情報喪失ありのサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  uint16_t num_ui16 = 257;
  uint8_t num_ui8 = num_ui16;
  
  printf("%d\n", num_ui8);
}
</pre>

出力結果です。

<pre>
1
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 257 16bit符号なし整数
00000001 00000001

// 1 8bit符号なし整数
00000001
</pre>

<h3>ビット幅の小さい浮動小数点型からビット幅の大きい浮動小数点型への変換(情報喪失なし)</h3>

ビット幅の小さい浮動小数点型からビット幅の大きい浮動小数点型への変換について解説します。

浮動小数点型として、<a href="/blog/20201202133213.html">float</a>,<a href="/blog/20201203133213.html">double</a>の場合を想定して解説します。

ビット幅の小さい浮動小数点型からビット幅の大きい浮動小数点型への変換は数値の情報は失われずに保持されます。

<pre>
#include <stdio.h>

int main(void) {
  
  // float型からdouble型へ変換
  float num_f = 2.5f;
  double num_d = num_f;
  
  printf("%f\n", num_d);
}
</pre>

出力結果です。

<pre>
2.500000
</pre>

<h3>ビット幅の大きい浮動小数点型からビット幅の小さい浮動小数点型への変換(情報喪失あり)</h3>

ビット幅の大きい浮動小数点型からビット幅の小さい浮動小数点型への変換について解説します。

浮動小数点型として、<a href="/blog/20201202133213.html">float</a>,<a href="/blog/20201203133213.html">double</a>の場合を想定して解説します。

ビット幅の大きい浮動小数点型からビット幅の小さい浮動小数点型への変換は、変更前の値が、変更後の型が表現できる有効桁数を超えていた場合は、有効桁数が変更後の型が表現できる有効桁数の最大になります。

<pre>
#include <stdio.h>

int main(void) {
  
  // double型からfloat型へ変換
  double num_d = 2.111111111111111111111111111111;
  float num_f = num_d;
  
  printf("double: %.50f\nfloat:  %.50f\n", num_d, num_f);
}
</pre>

出力結果です。精度が落ちていることが確認できます。

<pre>
double: 2.11111111111111116045435665000695735216140747070312
float:  2.11111116409301757812500000000000000000000000000000
</pre>

<h3>符号あり整数型から浮動小数点型への変換(情報喪失あり)</h3>

符号あり整数型から浮動小数点型への変換について解説します。

符号あり整数型を浮動小数点型に変換する場合は、数値の情報が失われる場合があります。

double型は64bitです。double型で正しく表現可能な整数型は、最大int32_t型までです。int64_t型の場合は、数値の情報が失われる場合があります。

float型は64bitです。float型で正しく表現可能な整数型は、最大int16_t型まです。int64_t型、int32_t型の場合は、数値の情報が失われる可能性があります。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int32_t型からdouble型へ変換
  int32_t num_i32 = INT32_MAX;
  double num_d = num_i32;
  
  printf("%f\n", num_d);
}
</pre>

出力結果です。int32_t型の最大値<a href="/blog/20201129082751.html">INT32_MAX</a>(2147483647)を、double型で表現できています。

<pre>
2147483647.000000
</pre>

数値の情報が失われるサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int32_t型からfloat型へ変換
  int32_t num_i32 = INT32_MAX;
  float num_f = num_i32;
  
  printf("%f\n", num_f);
}
</pre>

出力結果です。おや、精度が足りなかったため、よく見ると、値が変わっていますね。

<pre>
2147483648.000000
</pre>

<h3>浮動小数点型から符号あり整数型への変換(情報喪失あり)</h3>

浮動小数点型から符号あり整数型への変換について解説します。

浮動小数点型から符号あり整数型へ変換すると、小数点以下の情報が、削除されます。

doubleは、int64_t型への変換であれば、情報喪失はありません。それ以下のビット数の符号あり整数型の場合は、情報喪失が発生する可能性があります。

floatは、int32_t型への変換であれば、情報喪失はありません。それ以下のビット数の符号あり整数型の場合は、情報喪失が発生する可能性があります。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int32_t型からdouble型へ変換
  double num_d = 33.43;
  int64_t num_i64 = num_d;
  
  printf("%d\n", num_i64);
}
</pre>

出力結果です。

<pre>
33
</pre>

<h3>同一サイズの符号あり整数型と符号なし整数型の相互の変換(情報喪失なし)</h3>

同一サイズの符号あり整数型と符号なし整数型の相互の変換について解説します。

符号あり整数型として、<a href="/blog/20201117090747.html">int8_t</a>, <a href="/blog/20201126090559.html">int16_t</a>, <a href="/blog/20201130082751.html">int32_t</a>, <a href="/blog/20201127082751.html">int64_t</a>の場合を想定して解説します。

符号なし整数型として、<a href="/blog/20201122084622.html">uint8_t</a>, <a href="/blog/20201120084622.html">uint16_t</a>, <a href="/blog/20201111150850.html">uint32_t</a>, <a href="/blog/20201109150850.html">uint64_t</a>の場合を想定して解説します。

同一サイズの符号あり整数型と符号なし整数型の相互の変換は、内部のビット表現を変えません。内部のビット表現を、符号ありとして解釈するか、符号なしとして解釈するかという意味の変換のみになります。

同一サイズの符号あり整数型と符号なし整数型の相互の変換を行うサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  int8_t num_i8 = -1;
  uint8_t num_ui8= num_i8;
  
  printf("num_ui8: %d\n", num_ui8);
  
  int8_t num_i8_again = num_ui8;
  
  printf("num_i8_again: %d\n", num_i8_again);
}
</pre>

出力結果。

<pre>
num_ui8: 255
num_i8_again: -1
</pre>

ビットレベルでは、何の変換も行われていません。負の値は、2の補数で表現されていると想定します。

<pre>
// -1 8bit符号あり整数
11111111

// 255 8bit符号なし整数
11111111
</pre>

<h3>上記の解説はC言語仕様上の型変換規則の解説ではないのですか?</h3>

はい。上記の解説はC言語仕様上の型変換規則の解説ではありません。実用でよく使うである型変換を、例示的に示して、C言語仕様上の型変換規則と矛盾がないように解説したものです。
