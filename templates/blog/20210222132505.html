<h2>C言語の型変換規則 書きかけ</h2>

C言語の型変換規則について解説します。この解説では、よく使う型変換規則を中心にして、実用の観点から解説します。

<h3>ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換(情報喪失なし)</h3>

ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換について解説します。

符号つき整数型として、<a href="/blog/20201117090747.html">int8_t</a>, <a href="/blog/20201126090559.html">int16_t</a>, <a href="/blog/20201130082751.html">int32_t</a>, <a href="/blog/20201127082751.html">int64_t</a>の場合を想定して解説します。

ビット幅の小さい符号あり整数からビット幅の大きい符号あり整数への変換は数値の絶対値と符号の情報は失われずに保持されます。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int8_tからint32_tへ変換
  int8_t num_i8 = -15;
  int32_t num_i32 = num_i8;
  
  printf("%d\n", num_i32);
}
</pre>

出力結果です。

<pre>
-15
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -15 8bit符号あり整数
1001111

// -15 32bit符号あり整数
10000000 00000000 00000000 00001111
</pre>

<h3>ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換(情報喪失なし)</h3>

ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換について解説します。

符号なし整数型として、<a href="/blog/20201122084622.html">uint8_t</a>, <a href="/blog/20201120084622.html">uint16_t</a>, <a href="/blog/20201111150850.html">uint32_t</a>, <a href="/blog/20201109150850.html">uint64_t</a>の場合を想定して解説します。

ビット幅の小さい符号なし整数からビット幅の大きい符号なし整数への変換は数値の情報は失われずに保持されます。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int8_tからint32_tへ変換
  uint8_t num_ui8 = 15;
  uint32_t num_ui32 = num_ui8;
  
  printf("%d\n", num_ui32);
}
</pre>

出力結果です。

<pre>
15
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 15 8bit符号なし整数
0001111

// 15 32bit符号なし整数
00000000 00000000 00000000 00001111
</pre>

<h3>ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換(情報喪失あり)</h3>

ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換について解説します。

符号あり整数型として、<a href="/blog/20201117090747.html">int8_t</a>, <a href="/blog/20201126090559.html">int16_t</a>, <a href="/blog/20201130082751.html">int32_t</a>, <a href="/blog/20201127082751.html">int64_t</a>の場合を想定して解説します。

ビット幅の大きい符号あり整数からビット幅の小さい符号あり整数への変換は、上位ビットが切り捨てられて解釈された値になります。

正しく変換できるのは、変換前の値が、変換後の型で表現できる数値の範囲に収まっていた場合です。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  int16_t num_i16 = -128;
  int8_t num_i8 = num_i16;
  
  printf("%d\n", num_i8);
}
</pre>

出力結果です。

<pre>
-128
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -128 16bit符号あり整数
11111111 10000000

// -128 8bit符号あり整数
10000000
</pre>

情報喪失ありのサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  int16_t num_i16 = -257;
  int8_t num_i8 = num_i16;
  
  printf("%d\n", num_i8);
}
</pre>

出力結果です。

<pre>
-1
</pre>

2の補数表現で、マイナスを表現していると想定すると、次のようなビットレベルの変換が行われていることになります。

<pre>
// -257 16bit符号あり整数
11111110 11111111

// -1 8bit符号あり整数
11111111
</pre>

<h3>ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換(情報喪失あり)</h3>

ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換について解説します。

符号なし整数型として、<a href="/blog/20201122084622.html">uint8_t</a>, <a href="/blog/20201120084622.html">uint16_t</a>, <a href="/blog/20201111150850.html">uint32_t</a>, <a href="/blog/20201109150850.html">uint64_t</a>の場合を想定して解説します。

ビット幅の大きい符号なし整数からビット幅の小さい符号なし整数への変換は、上位ビットが切り捨てられて解釈された値になります。

正しく変換できるのは、変換前の値が、変換後の型で表現できる数値の範囲に収まっていた場合です。

正しく変換できた場合のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  uint16_t num_ui16 = 255;
  uint8_t num_ui8 = num_ui16;
  
  printf("%d\n", num_ui8);
}
</pre>

出力結果です。

<pre>
255
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 255 16bit符号なし整数
00000000 10000000

// -128 8bit符号なし整数
10000000
</pre>

情報喪失ありのサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  
  // int16_tからint8_tへ変換
  uint16_t num_ui16 = 257;
  uint8_t num_ui8 = num_ui16;
  
  printf("%d\n", num_ui8);
}
</pre>

出力結果です。

<pre>
1
</pre>

次のようなビットレベルの変換が行われていることになります。

<pre>
// 257 16bit符号なし整数
00000001 00000001

// 1 8bit符号なし整数
00000001
</pre>
