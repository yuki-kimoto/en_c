<h2>ビット演算子</h2>

C言語のビット演算子について解説します。ビット演算とは、1ビット単位で行われる演算のことをいいます。

<table>
  <tr><th>ビットAND演算子</th><td>&</td></tr>
  <tr><th>ビットOR演算子</th><td>|</td></tr>
  <tr><th>ビットXOR演算子</th><td>^</td></tr>
  <tr><th>ビットNOT演算子</th><td>~</td></tr>
</table>

<h3>ビットAND演算子</h3>

ビットAND演算子「&」は、二つのオペランドに含まれるあるビットが両方とも1の場合に、返却する値の対応する位置に1に設定し、あるビットのどちらかが0の場合は0を設定します。

<pre>
# ビットAND
x & y
</pre>

xとyが両方とも<a href="/blog/20201122084622.html">8bit符号なし整数型</a>であるとしましょう。zがビットAND演算子の結果の値です。xとyのある位置の両方のビットが1の場合に、対応するzのビットも1になり、それ以外の場合は0になります。

<pre>
x 01001100
y 01000101

z 01000100
</pre>

ビットAND演算子のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  // 01001100
  uint8_t x = 0x4C;
  
  // 01000101
  uint8_t y = 0x45;
  
  // 01000100
  uint8_t z = x & y;
  
  printf("%X\n", z);
}
</pre>

出力結果です。16進数での出力ですが、2進数であれば「01000100」です。

<pre>
44
</pre>

<h3>ビットOR演算子</h3>

ビットOR演算子「|」は、二つのオペランドに含まれるあるビットのどちらかが1(どちらも1でもよい)の場合に、返却する値の対応する位置に1に設定し、あるビットの両方が0の場合は0を設定します。

<pre>
# ビットOR
x | y
</pre>

xとyが両方とも<a href="/blog/20201122084622.html">8bit符号なし整数型</a>であるとしましょう。zがビットOR演算子の結果の値です。xとyのある位置のどちらかのビットが1の場合に、対応するzのビットも1になり、両方とも0の場合は0になります。

<pre>
x 01001100
y 01000101

z 01001101
</pre>

ビットOR演算子のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  // 01001100
  uint8_t x = 0x4C;
  
  // 01000101
  uint8_t y = 0x45;
  
  // 01001101
  uint8_t z = x | y;
  
  printf("%X\n", z);
}
</pre>

出力結果です。16進数での出力ですが、2進数であれば「01001101」です。

<pre>
4D
</pre>

<h3>ビットXOR演算子</h3>

ビットXOR演算子「^」は、二つのオペランドに含まれるあるビットがのどちらかだけが1の場合に、返却する値の対応する位置に1に設定し、あるビットの両方が0あるいは1の場合は0を設定します。

<pre>
# ビットXOR
x ^ y
</pre>

xとyが両方とも<a href="/blog/20201122084622.html">8bit符号なし整数型</a>であるとしましょう。zがビットXOR演算子の結果の値です。xとyのある位置のどちらかだけのビットが1の場合に、対応するzのビットも1になり、両方とも0または1の場合は0になります。

<pre>
x 01001100
y 01000101

z 00001001
</pre>

ビットXOR演算子のサンプルです。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  // 01001100
  uint8_t x = 0x4C;
  
  // 01000101
  uint8_t y = 0x45;
  
  // 0001001
  uint8_t z = x ^ y;
  
  printf("%X\n", z);
}
</pre>

出力結果です。16進数での出力ですが、2進数であれば「0001001」です。

<pre>
9
</pre>

<h3>ビットNOT演算子</h3>

ビットNOT演算子「~」は、オペランドに含まれるあるビットを反転させます。

<pre>
# ビットNOT
~x
</pre>

xとyが両方とも<a href="/blog/20201122084622.html">8bit符号なし整数型</a>であるとしましょう。zがビットNOT演算子の結果の値です。xのビットが反転しています。

<pre>
x 01001100

z 10110011
</pre>

ビットNOT演算子のサンプルです。出力結果は、<a href="http://59.106.185.196:3000/blog/20210218081559.html">整数型拡張</a>の影響をなくすために「0xFF」とのビットANDをとっています。

<pre>
#include <stdio.h>
#include <stdint.h>

int main(void) {
  // 01001100
  uint8_t x = 0x4C;
  
  // 01000101
  uint8_t y = 0x45;
  
  // 10110011
  uint8_t z = ~x;
  
  printf("%X\n", z);
}
</pre>

出力結果です。16進数での出力で、すが、2進数であれば「01000100」です。

<pre>
B3
</pre>

<h3>ビット演算子と「=」を組み合わせた特殊演算子</h3>

ビット演算子と「=」を組み合わせた特殊演算子があります。
<pre>
# 「x = x & y」 と同じ意味
x &= y

# 「x = x | y」 と同じ意味
x |= y

# 「x = x ^ y」 と同じ意味
x ^= y
</pre>

<h3>ビット演算子は実務ではどのような場合に使用しますか?</h3>

ビット演算子を一番使う場面は、フラグを関数の引数に渡す場合です。C言語では、フラグを、整数で渡すことが多いのですが、その場合に、ビットの位置で意味を定めます。<a href="/blog/20210120133501.html">列挙型enum</a>を使って、各ビットのフラグを定義します。1(二進で1), 2(二進で10), 4(二進で100), 8(二進で1000)。

各ビットを立てるときはビットOR「|=」、落とすときはビットXOR「^=」です。

ビットが立っているかをチェックするときは「&」を使います。

関数の引数に渡すフラグを作成するサンプルコードです。

<pre>
#include <stdio.h>
#include <stdint.h>

enum {
  MYAPP_FLAG1 = 1,
  MYAPP_FLAG2 = 2,
  MYAPP_FLAG3 = 4,
  MYAPP_FLAG4 = 8,
  MYAPP_FLAG5 = 16,
  MYAPP_FLAG6 = 32,
  MYAPP_FLAG7 = 64,
  MYAPP_FLAG8 = 128,
  MYAPP_FLAG9 = 256,
  MYAPP_FLAG10 = 512,
};

int main(void) {
  uint32_t flag = 0;
  
  // MYAPP_FLAG4をたてる
  flag |= MYAPP_FLAG4;
  
  // 00000000 00000000 00000000 00001000
  printf("%X\n", flag);
  
  // MYAPP_FLAG10をたてる
  flag |= MYAPP_FLAG10;

  // 00000000 00000000 00000010 00001000
  printf("%X\n", flag);
  
  // MyAPP_FLAG4を落とす
  flag ^= MYAPP_FLAG4;
  
  // 00000000 00000000 00000010 00000000
  printf("%X\n", flag);
  
  // ビットが立っているかチェック
  if (flag & MYAPP_FLAG10) {
    printf("MYAPP_FLAG10 ok\n");
  }
}
</pre>
