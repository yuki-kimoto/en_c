<div class = "bread">
  <ul itemscope itemtype = "http://schema.org/BreadcrumbList">
    <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
      <a itemprop="item" href="/">
        <span itemprop = "name"> C language </ span>
      </a>
      <meta itemprop = "position" content = "1" />
    </ li>
    <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
      <a itemprop="item" href="/syntax.html">
        <span itemprop = "name"> Basic grammar </ span>
      </a>
      <meta itemprop = "position" content = "2" />
    </ li>
    <li>
      here
    </ li>
  </ ul>
</ div>

<h2> Function definition </ h2>

I will explain the definition of the function. A function is a collection of functions. Describe the function name, argument name and its type and number, return type, and processing content.

<pre>
// Function definition
Return type Function name (argument type 1 argument name 1, argument type 2 argument name 2, ...) {
  // Processing content
}
</ pre>

When calling the defined function, write as follows.

<pre>
// Function call
Function name (value 1, value 2, ...);
</ pre>

Before calling a function, it is necessary to know the function name, the type and number of arguments, and the type of the return value by "defining the function" or "declaring the prototype of the function".

<h3> Function that outputs Hello World! </ H3>

First, let's define a function with no arguments and no return value and call the function. If there is no argument, specify "void". If there is no return value, specify "void". Void is a special type that expresses that it does not exist. Note that if void is not written like "print_hello ()" in the argument part of the function definition, it means "arbitrary number of arguments of unknown type".

<pre>
#include <stdio.h>

// Function definition
void myapp_print_hello (void) {
  printf ("Hello World! \ N");
}

int main (void) {
  // Function call
  myapp_print_hello ();
}
</ pre>

This is the output result.

<pre>
Hello World!
</ pre>

<h3> Function that adds two int32_t type numbers </ h3>

Let's define a function that adds two <a href="/blog/20201130082751.html"> int32_t </a> numbers.

<pre>
#include <stdio.h>
#include <stdint.h>

// Function definition
int32_t myapp_sum (int32_t num1, int32_t num2) {
  int32_t total = num1 + num2;
  return total;
}

int main (void) {
  // Function call
  int32_t num1 = 1;
  int32_t num2 = 5;
  int32_t total = myapp_sum (num1, num2);
  printf ("% d \ n", total);
}
</ pre>

Output result

<pre>
6
</ pre>

<h3> Function to find the sum of dynamically generated arrays </ h3>

It is a function to calculate the sum of <a href="/blog/20210129143859.html"> array </a> dynamically generated by <a href="/blog/20210209082644.html"> calloc function </a>. The point is to use <a href="/blog/20210211090234.html"> pointer type </a> as an argument.

<pre>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// Function definition
int32_t myapp_sum_array (int32_t * nums, int32_t nums_length) {
  int32_t total = 0;
  for (int32_t i = 0; i <nums_length; i ++) {
    total + = nums [i];
  }
  return total;
}

int main (void) {
  // Function call
  int32_t nums_length = 3;
  int32_t * nums = calloc (sizeof (int32_t), nums_length);
  nums [0] = 1;
  nums [1] = 2;
  nums [2] = 3;
  int32_t total = myapp_sum_array (nums, nums_length);
  printf ("% d \ n", total);
  
  free (nums);
}
</ pre>

Output result.

<pre>
6
</ pre>

<h3> Pass the contents of the structure as an argument </ h3>

Let's write a function that changes the contents of the dynamically generated <a href="/blog/20210208155548.html"> structure </a>. The point is to define the argument as a pointer type.

<pre>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// Structure definition
struct myapp_book {
  int32_t id;
  const char * name;
};;

// Function definition
void myapp_init_book (struct myapp_book * book) {
  book-> id = 1;
  book-> name = "C99 Tutorial";
}

int main (void) {
  struct myapp_book * book = calloc (sizeof (struct myapp_book), 1);
  
  // Function call
  myapp_init_book (book);
  
  printf ("id:% d, name:% s \ n", book-> id, book-> name);
  
  free (book);
}
</ pre>

Output result.

<pre>
id: 1, name: C99 Tutorial
</ pre>

<h3> Function prototype declaration </ h3>

We've covered function definitions above, but in practice there are more recommended ways to write them.

It is a split compilation method in which the prototype declaration of a function is made in the header and the function definition is made in the source code.

The prototype declaration of the function is written as follows. The argument name can be omitted. The return type, function name, and argument type should be the same as in the function definition.

<pre>
// Function prototype declaration
Return type Function name (argument type 1 argument name 1, argument type 2 argument name 2, ...);
</ pre>

In C, the function definition must precede the function call.

If the function definition is after the function call, it's best to assume that you'll get a compilation error.

gcc implicitly resolves and issues a warning.

<pre>
#include <stdio.h>
#include <stdint.h>

int main (void) {
  // Function call
  int32_t num1 = 1;
  int32_t num2 = 5;
  int32_t total = myapp_sum (num1, num2);
  printf ("% d \ n", total);
}

// The function definition is after the function call
int32_t myapp_sum (int32_t num1, int32_t num2) {
  int32_t total = num1 + num2;
  return total;
}
</ pre>

A warning is issued with gcc.

<pre>
a.c: 8: warning: implicit declaration of function ‘myapp_sum’
</ pre>

Let's add a function prototype declaration before the function call. The warning will disappear.

<pre>
#include <stdio.h>
#include <stdint.h>

// Function prototype declaration
int32_t myapp_sum (int32_t num1, int32_t num2);

int main (void) {
  // Function call
  int32_t num1 = 1;
  int32_t num2 = 5;
  int32_t total = myapp_sum (num1, num2);
  printf ("% d \ n", total);
}

// Function definition
int32_t myapp_sum (int32_t num1, int32_t num2) {
  int32_t total = num1 + num2;
  return total;
}
</ pre>

In the function prototype declaration, it seems better to omit the argument name and leave only the type and function name because it avoids macro expansion of the argument name.

<pre>
#include <stdio.h>
#include <stdint.h>

// Function prototype declaration (better, but I can't just copy and paste ...)
int32_t myapp_sum (int32_t, int32_t);

int main (void) {
  // Function call
  int32_t num1 = 1;
  int32_t num2 = 5;
  int32_t total = myapp_sum (num1, num2);
  printf ("% d \ n", total);
}

// Function definition
int32_t myapp_sum (int32_t num1, int32_t num2) {
  int32_t total = num1 + num2;
  return total;
}
</ pre>

<h3> Example of split compilation </ h3>

Here is an example of split compilation. When writing C language in practice, it is recommended to write in this way.

<h4> myapplib.h </ h4>

This is a header file. Write a prototype declaration for the function. The "#ifndef MYAPPLIB_H" part is <a href="/blog/20210201153503.html"> include guard </a>.

<pre>
#ifndef MYAPPLIB_H
#define MYAPPLIB_H

#include <stdint.h>

// Function prototype declaration
int32_t myapp_sum (int32_tnum1, int32_t num2);

#endif
</ pre>

<h4> myapplib.c </ h4>

This is a C language source file with function definitions.

<pre>
#include <stdint.h>

// Function definition
int32_t myapp_sum (int32_t num1, int32_t num2) {
   int32_t total = num1 + num2;
   return total;
}
</ pre>

<h4> myapp.c </ h4>

The C language source code of the body of the application. Loading "myapplib.h".

<pre>
#include <stdio.h>
#include <stdint.h>

#include "myapplib.h"

int main (void) {
   // Function call
   int32_t num1 = 1;
   int32_t num2 = 5;
   int32_t total = myapp_sum (num1, num2);
   printf ("% d \ n", total);
}
</ pre>

<h4> Compile, link and run </ h4>

<pre>
gcc -c myapplib.c
gcc -c myapp.c
gcc -o myapp myapp.o myapplib.o
./myapp
</ pre>

Output result.

<pre>
6
</ pre>